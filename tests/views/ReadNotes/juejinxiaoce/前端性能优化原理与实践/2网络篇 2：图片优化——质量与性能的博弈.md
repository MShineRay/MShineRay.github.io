# 图片优化——质量与性能的博弈

《高性能网站建设指南》的作者 Steve Souders 曾在 2013 年的一篇 
[博客](http://www.stevesouders.com/blog/2013/04/26/i/)
中提到：

> 我的大部分性能优化工作都集中在 JavaScript 和 CSS 上，从早期的 Move Scripts to the Bottom 和 Put Stylesheets at the Top 规则。为了强调这些规则的重要性，我甚至说过，“JS 和 CSS 是页面上最重要的部分”。
> 
> 几个月后，我意识到这是错误的。图片才是页面上最重要的部分。
> 
> 我关注 JS 和 CSS 的重点也是如何能够更快地下载图片。图片是用户可以直观看到的。他们并不会关注 JS 和 CSS。确实，JS 和 CSS 会影响图片内容的展示，尤其是会影响图片的展示方式（比如图片轮播，CSS 背景图和媒体查询）。但是我认为 JS 和 CSS 只是展示图片的方式。在页面加载的过程中，应当先让图片和文字先展示，而不是试图保证 JS 和 CSS 更快下载完成。

此外，雅虎军规和 Google 官方的最佳实践也都将图片优化列为前端性能优化必不可少的环节——图片优化的优先级可见一斑。

就图片这块来说，与其说我们是在做“优化”，不如说我们是在做“权衡”。
因为我们要做的事情，就是去压缩图片的体积（或者一开始就选取体积较小的图片格式）。
但这个优化操作，是以牺牲一部分成像质量为代价的。
因此我们的主要任务，是尽可能地去寻求一个质量与性能之间的平衡点。

## 2018 年，图片依然很大

[HTTP-Archive](https://httparchive.org/reports/page-weight#bytesTotal) 这个网站，它会定期抓取 Web 上的站点，并记录资源的加载情况、Web API 的使用情况等页面的详细信息，并会对这些数据进行处理和分析以确定趋势。通过它我们可以实时地看到世界范围内的 Web 资源的统计结果。

## 不同业务场景下的图片方案选型

 Web 图片格式有 JPEG/JPG、PNG、WebP、Base64、SVG 等。 
 雪碧图（CSS Sprites）。

### 二进制位数与色彩的关系

在计算机中，像素用二进制数来表示。不同的图片格式中像素与二进制位数之间的对应关系是不同的。
一个像素对应的二进制位数越多，它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。

一个二进制位表示两种颜色（0|1 对应黑|白），如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 种颜色。

### JPEG/JPG

关键字：**有损压缩、体积小、加载快、不支持透明**

#### JPG 的优点

JPG 最大的特点是**有损压缩**。这种高效的压缩算法使它成为了一种非常轻巧的图片格式。
另一方面，即使被称为“有损”压缩，JPG的压缩方式仍然是一种高质量的压缩方式：
当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。
此外，JPG 格式以 24 位存储单个图，可以呈现多达 1600 万种颜色，
足以应对大多数场景下对色彩的要求，这一点决定了它压缩前后的质量损耗并不容易被我们人类的肉眼所察觉——前提是你用对了业务场景。

#### 使用场景

JPG 适用于呈现色彩丰富的图片，JPG 图片经常作为大的背景图、轮播图或 Banner 图出现。

两大电商网站对大图的处理，是 JPG 图片应用场景的最佳写照：

使用 JPG 呈现大图，既可以保住图片的质量，又不会带来令人头疼的图片体积，是当下比较推崇的一种方案。

#### JPG 的缺陷

有损压缩在上文所展示的轮播图上确实很难露出马脚，
但当它处理**矢量图形**和 **Logo** 等线条感较强、颜色对比强烈的图像时，
人为压缩导致的图片模糊会相当明显。

此外，JPEG 图像**不支持透明度处理**，透明图片需要召唤 PNG 来呈现。

### PNG-8 与 PNG-24

关键字：**无损压缩、质量高、体积大、支持透明**

#### PNG 的优点

PNG（可移植网络图形格式）是一种无损压缩的高保真的图片格式。
8 和 24，这里都是二进制数的位数。
8 位的 PNG 最多支持 256 种颜色，而 24 位的可以呈现约 1600 万种颜色。

PNG 图片具有比 JPG 更强的色彩表现力，对线条的处理更加细腻，对透明度有良好的支持。
它弥补了上文我们提到的 JPG 的局限性，唯一的 BUG 就是**体积太大**。

#### PNG-8 与 PNG-24 的选择题

理论上来说，当你追求最佳的显示效果、并且不在意文件体积大小时，是推荐使用 PNG-24 的。

但实践当中，为了规避体积的问题，我们一般不用PNG去处理较复杂的图像。
当我们遇到适合 PNG 的场景时，也会优先选择更为小巧的 PNG-8。

如何确定一张图片是该用 PNG-8 还是 PNG-24 去呈现呢？
好的做法是把图片先按照这两种格式分别输出，看 PNG-8 输出的结果是否会带来肉眼可见的质量损耗，
并且确认这种损耗是否在我们（尤其是你的 UI 设计师）可接受的范围内，
基于对比的结果去做判断。

#### 应用场景

复杂的、色彩层次丰富的图片，用 PNG 来处理的话，成本会比较高， 我们一般会交给 JPG 去存储。

考虑到 PNG 在处理线条和颜色对比度方面的优势，我们主要用它来呈现小的 Logo、颜色简单且对比强烈的图片或背景等。

此时我们再次把目光转向性能方面堪称业界楷模的淘宝首页，我们会发现它页面上的 Logo，无论大小，还真的都是 PNG 格式：

颜色简单、对比度较强的透明小图也在 PNG 格式下有着良好的表现：

### SVG

关键字：**文本文件、体积小、不失真、兼容性好**

SVG（可缩放矢量图形）是一种基于 XML 语法的图像格式。
它和本文提及的其它图片种类有着本质的不同：SVG 对图像的处理不是基于像素点，
而是是基于对图像的形状描述。

#### SVG 的特性

SVG 与 PNG 和 JPG 相比，**文件体积更小，可压缩性更强**。

当然，作为矢量图，它最显著的优势还是在于**图片可无限放大而不失真**这一点上。
这使得 SVG 即使是被放到视网膜屏幕上，也可以一如既往地展现出较好的成像品质——1 张 SVG 足以适配 n 种分辨率。

此外，**SVG 是文本文件**。我们既可以像写代码一样定义 SVG，把它写在 HTML 里、成为 DOM 的一部分，
也可以把对图形的描述写入以 .svg 为后缀的独立文件（SVG 文件在使用上与普通图片文件无异）。
这使得 SVG 文件可以被非常多的工具读取和修改，具有较强的**灵活性**。

SVG 的局限性主要有两个方面，一方面是它的渲染成本比较高，这点对性能来说是很不利的。
另一方面，SVG 存在着其它图片格式所没有的学习成本（它是可编程的）。

#### SVG 的使用方式与应用场景

SVG 是文本文件，我们既可以像写代码一样定义 SVG，把它写在 HTML 里、成为 DOM 的一部分，也可以把对图形的描述写入以 .svg 为后缀的独立文件（SVG 文件在使用上与普通图片文件无异）。

*   将 SVG 写入 HTML：
    
    ```
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
    </head>
    <body>
        <svg xmlns="http://www.w3.org/2000/svg"   width="200" height="200">
            <circle cx="50" cy="50" r="50" />
        </svg>
    </body>
    </html>
    
    ```
    
*   将 SVG 写入独立文件后引入 HTML:
    
    ```
    <img src="文件名.svg" alt="">
    
    ```
    

在实际开发中，我们更多用到的是后者。
[在线矢量图形库](http://www.iconfont.cn/)

### Base64

关键字：**文本文件、依赖编码、小图标解决方案**

Base64 并非一种图片格式，而是一种编码方式。Base64 和雪碧图一样，是作为小图标解决方案而存在的。

#### 最经典的小图标解决方案——雪碧图（CSS Sprites）

雪碧图、CSS 精灵、CSS Sprites、图像精灵，说的都是这个东西——一种将小图标和背景图像合并到一张图片上，然后利用 CSS 的背景定位来显示其中的每一部分的技术。

> 图像精灵（sprite，意为精灵），被运用于众多使用大量小图标的网页应用之上。它可取图像的一部分来使用，使得使用一个图像文件替代多个小文件成为可能。
> 相较于一个小图标一个图像文件，单独一张图片所需的 HTTP 请求更少，对内存和带宽更加友好。

Base64 图片的出现，也是为了减少加载网页图片时对服务器的请求次数，从而提升网页性能。**Base64 是作为雪碧图的补充而存在的。**

#### 理解 Base64

每次加载图片，都是需要单独向服务器请求这个图片对应的资源的——这也就意味着一次 HTTP 请求的开销。

**Base64 是一种用于传输 8Bit 字节码的编码方式，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数。**

#### Base64 的应用场景

既然 Base64 这么棒，我们何不把大图也换成 Base64 呢？

这是因为，Base64 编码后，图片大小会膨胀为原文件的 4/3（这是由 Base64 的编码原理决定的）。
如果我们把大图也编码到 HTML 或 CSS 文件中，后者的体积会明显增加，即便我们减少了 HTTP 请求，也无法弥补这庞大的体积带来的性能开销，得不偿失。  
在传输非常小的图片的时候，Base64 带来的文件体积膨胀、以及浏览器解析 Base64 的时间开销，与它节省掉的 HTTP 请求开销相比，可以忽略不计，这时候才能真正体现出它在性能方面的优势。

因此，Base64 并非万全之策，我们往往在一张图片满足以下条件时会对它应用 Base64 编码：

*   图片的实际尺寸很小（大家可以观察一下掘金页面的 Base64 图，几乎没有超过 2kb 的）
*   图片无法以雪碧图的形式与其它小图结合（合成雪碧图仍是主要的减少 HTTP 请求的途径，Base64 是雪碧图的补充）
*   图片的更新频率非常低（不需我们重复编码和修改文件内容，维护成本较低）

#### Base64 编码工具推荐

这里最推荐的是利用 webpack 来进行 Base64 的编码——webpack 的 
[url-loader](https://github.com/webpack-contrib/url-loader) 
非常聪明，它除了具备基本的 Base64 转码能力，还可以结合文件大小，帮我们判断图片是否有必要进行 Base64 编码。

### WebP

关键字：**年轻的全能型选手**

WebP 是今天在座各类图片格式中最年轻的一位，它于 2010 年被提出， 是 Google 专为 Web 开发的一种**旨在加快图片加载速度**的图片格式，它支持有损压缩和无损压缩。

#### WebP 的优点

WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片——它集多种图片文件格式的优点于一身。  
WebP 的官方介绍对这一点有着更权威的阐述：

> 与 PNG 相比，WebP 无损图像的尺寸缩小了 26％。
> 在等效的 SSIM 质量指数下，WebP 有损图像比同类 JPEG 图像小 25-34％。 
> 无损 WebP 支持透明度（也称为 alpha 通道），仅需 22％ 的额外字节。
> 对于有损 RGB 压缩可接受的情况，有损 WebP 也支持透明度，
> 与 PNG 相比，通常提供 3 倍的文件大小。

#### WebP 的局限性

WebP 还会增加服务器的负担——和编码 JPG 文件相比，编码同样质量的 WebP 文件会占用更多的计算资源。

#### WebP 的应用场景

现在限制我们使用 WebP 的最大问题不是“这个图片是否适合用 WebP 呈现”的问题，而是“浏览器是否允许 WebP”的问题，即我们上文谈到的兼容性问题。
具体来说，一旦我们选择了 WebP，就要考虑在 Safari 等浏览器下它无法显示的问题，
也就是说我们需要准备 PlanB，准备降级方案。

```
<img src="//img.alicdn.com/tps/i4/TB1CKSgIpXXXXccXXXX07tlTXXX-200-200.png_60x60.jpg_.webp" alt="手机app - 聚划算" class="app-icon">

```

.webp 前面，还跟了一个 .jpg 后缀！

我们现在先大胆地猜测，这个图片应该至少存在 jpg 和 webp 两种格式，程序会根据浏览器的型号、以及该型号是否支持 WebP 这些信息来决定当前浏览器显示的是 .webp 后缀还是 .jpg 后缀。
带着这个预判，我们打开并不支持 WebP 格式的 Safari 来进入同样的页面，再次搜索 WebP 关键字：


Safari 提示我们找不到，这也是情理之中。我们定位到刚刚示例的 WebP 图片所在的元素，查看一下它在 Safari 里的图片链接：

```
<img src="//img.alicdn.com/tps/i4/TB1CKSgIpXXXXccXXXX07tlTXXX-200-200.png_60x60.jpg" alt="手机app - 聚划算" class="app-icon">

```

我们看到同样的一张图片，在 Safari 中的后缀从 .webp 变成了 .jpg！看来果然如此——站点确实是先进行了兼容性的预判，在浏览器环境支持 WebP 的情况下，优先使用 WebP 格式，否则就把图片降级为 JPG 格式（本质是对图片的链接地址作简单的字符串切割）。

此外，还有另一个维护性更强、更加灵活的方案——把判断工作交给后端，由服务器根据 HTTP 请求头部的 Accept 字段来决定返回什么格式的图片。
当 Accept 字段包含 image/webp 时，就返回 WebP 格式的图片，否则返回原图。
这种做法的好处是，当浏览器对 WebP 格式图片的兼容支持发生改变时，我们也不用再去更新自己的兼容判定代码，
只需要服务端像往常一样对 Accept 字段进行检查即可。